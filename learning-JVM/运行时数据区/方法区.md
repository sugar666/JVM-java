---

---

# 方法区



# 栈、堆、方法区的交互关系

## 从线程中是否共享来区分



一般说堆的时候，就直接的包含年轻代与老年代，不包含永久代或方法区



元空间与永久代的区别：元空间使用本地内存，永久代使用JVM中的内存

内存泄露：没用的对象不能被GC

常量池与运行时常量池

非静态的方法在局部变量表中，0索引的位置存放的是 this

操作数栈，本地变量表（相当于一个数组，保存着的变量名称，名称对应着一个索引，可以保存对应变量的值）（局部变量表中也可以保存变量的值，并不是只有一个引用信息，直接的指向操作数栈？？？）


技术的提升，多问为什么

技术的深度，对问题的理解，评估学习能力，（多问为什么，不会的就去百度）

StringTable(字符串常量池)为什么变化：放在堆中，（静态变量也放在了堆中）

- 永久代的回收的效率是比较低的，在full GC的时候才会触发，full GC是在老年代空间不足，或者永久代空间不足的时候才会被触发，倒找了StringTable的回收效率不高，
- 但是，在开发中有大量的字符串被创建。回收的效率很低，永久代的空间不足，放在堆中，有利于及时的回收内存（永久代本来就是在堆中的，但是需要进行FUll GC）

**_*引用名的变化*_**



方法区(Person)

对象放在哪里？(堆)

对象本身放在哪(栈)





java中垃圾收集的主要的内容：常量池中废弃的常量和不在使用的类型



在方法区中的类会记录由什么类加载器进行加载的，类加载器也会记录加载了什么方法，便于方法区中的垃圾回收(类加载器被回收了是很难实现的)





JVM的内存模型



对象在创建的时候，会使用CAS进行加锁，失败重试



给对象的属性赋值操作： 

- 默认初始化

- 显示初始化
- 代码块中初始化
- 构造器初始化

**都在init中可以找到，第6步的init**

(属性显示的初始化，代码块初始化，构造器初始化)



**只有static对象在进行类加载的时候，才会赋予默认值，final修饰的在编译期间就进行了初始化，实例属性是在创建对象的时候进行初始化的**



对象的对象头：对象所属的类，



对象的内存布局：

- 对象头
  - 运行时元数据
  - 类型指针(obj.getClass)，不是所有的对象都有类型指针
  - 如果是数组，还需要记录数组的长度
- 实例数据
- 对齐填充



```java
{
  final int i;
    descriptor: I
    flags: ACC_FINAL
    ConstantValue: int 8

  int j;
    descriptor: I
    flags:

  public com.atguigu.java1.Test();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: bipush        8
         7: putfield      #2                  // Field i:I
        10: aload_0
        11: bipush        9
        13: putfield      #3                  // Field j:I
        16: return
      LineNumberTable:
        line 7: 0
        line 9: 4
        line 10: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      17     0  this   Lcom/atguigu/java1/Test;

```



final对象在编译的时候就会被初始化，

找到指定的class文件，使用 `javap -v -p class名称` 查看对应的字节码文件， `-p`可以查看隐藏的字节码



```java
{
  final int i;
    descriptor: I
    flags: ACC_FINAL
    ConstantValue: int 8

  int j;
    descriptor: I
    flags:

  public com.atguigu.java1.Test();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: bipush        8
         7: putfield      #2                  // Field i:I
        10: aload_0
        11: bipush        9
        13: putfield      #3                  // Field j:I
        16: return
      LineNumberTable:
        line 7: 0
        line 9: 4
        line 10: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      17     0  this   Lcom/atguigu/java1/Test;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 14: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       1     0  args   [Ljava/lang/String;

  private void testP();
    descriptor: ()V
    flags: ACC_PRIVATE
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 18: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       1     0  this   Lcom/atguigu/java1/Test;
}
SourceFile: "Test.java"
```

不使用，看不到

```java
{
  final int i;
    descriptor: I
    flags: ACC_FINAL
    ConstantValue: int 8

  int j;
    descriptor: I
    flags:

  public com.atguigu.java1.Test();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: bipush        8
         7: putfield      #2                  // Field i:I
        10: aload_0
        11: bipush        9
        13: putfield      #3                  // Field j:I
        16: return
      LineNumberTable:
        line 7: 0
        line 9: 4
        line 10: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      17     0  this   Lcom/atguigu/java1/Test;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 14: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       1     0  args   [Ljava/lang/String;
}
SourceFile: "Test.java"

```



如何通过栈帧中的对象引用访问到其内部的对象实例？？？

直接指针的方式效率要到点

但是句柄稳定，对空间中的对象实例进行了移动，在虚拟机栈中的referrence中的引用不用改变



